// project_euler.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <string>
#include <chrono>
#include <vector>
#include <cassert>
#include <numeric>
#include <algorithm>
#include <functional>
#include <map>
#include <sstream>

#include <amp.h>

using namespace std;

void project1(int method) {
	std::cout << "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.\n";
	std::cout << "The sum of these multiples is 23.\n";
	std::cout << "Find the sum of all the multiples of 3 or 5 below 1000.\n";

	enum class Method {
		kFirst = 1,
		kSecond
	} const m = static_cast<Method>(method);
	switch (m) {
	case Method::kFirst: {
		int sum = 0;
		for (int i = 1; i < 1000; ++i) {
			if (i % 3 == 0 || i % 5 == 0) {
				sum += i;
			}
		}
		std::cout << "Result: " << sum << '\n';
		//233168, 0ms
		break;
	}
	case Method::kSecond: {
		std::vector<int> naturals(1000);
		auto n = 0;
		std::vector<int> numbers(1000);
		std::iota(std::begin(naturals), std::end(naturals), 0);
		std::for_each(std::begin(naturals), std::end(naturals), [&numbers](int i) {
			if (i % 3 == 0 || i % 5 == 0) {
				numbers.emplace_back(i);
			}
		});
		const auto sum = std::accumulate(std::begin(numbers), std::end(numbers), 0);
		std::cout << "Result: " << sum << '\n';
		//233168, 0ms
		break;
	}
	default:
		std::cout << "Unimplemented method: " << method << '\n';
		std::cout << "Expected 1 or 2\n";
	}
}

void project2(int method) {
	std::cout << "Each new term in the Fibonacci sequence is generated by adding the previous two terms.\n";
	std::cout << "By starting with 1 and 2, the first 10 terms will be:\n\n";
	std::cout << "1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\n";
	std::cout << "By considering the terms in the Fibonacci sequence whose values do not exceed four million,\n";
	std::cout << "find the sum of the even - valued terms.\n";

	__int64 sum = 2;
	int32_t f1 = 1;
	int32_t f2 = 2;
	int32_t f = 0;
	while (f <= 4e6) {
		f = f1 + f2;
		if (f % 2 == 0) {
			sum += f;
		}
		f1 = f2;
		f2 = f;
	}
	std::cout << "Result: " << sum << '\n';
}

inline bool IsPrime(const int primes[], int prime_count, int test) {
	int top_prime_limit = test;
	for (int i = 0; i < prime_count; ++i) {
		const int prime = primes[i];
		if (prime > top_prime_limit) {
			return true;
		}

		if (test % prime == 0) {
			return false;
		}

		top_prime_limit = test / prime;
	}

	return true;
}

inline bool IsPrime(int64_t test) {
	for (int64_t i = 3, len = test - 1; i < len; i += 2) {
		if (test % i == 0) {
			return false;
		}
	}

	return true;
}

void project3(int method) {
	std::cout << "The prime factors of 13195 are 5, 7, 13 and 29.\n";
	std::cout << "What is the largest prime factor of the number 600851475143 ?\n";
	//answer: 6857
	enum class Method {
		kFirst = 1,
		kSecond
	} const m = static_cast<Method>(method);

	int64_t max_prime_factor = -1;

	switch (m) {
	case Method::kFirst: {
		//the most basic method
		const int64_t number = 600851475143;
		for (int64_t factor = 3; factor < number; factor += 2) {
			if (number % factor == 0) {
				if (IsPrime(factor) && factor > max_prime_factor) {
					max_prime_factor = factor;
				}
			}
		}
		break;
	}
	case Method::kSecond: {
		//more advance faster way to find biggest prime factors
		std::stringstream factors;
		int64_t number = 600851475143;
		int64_t factor = 3;
		for (; factor <= number; factor += 2) {
			while (number % factor == 0) {
				if (IsPrime(factor)) {
					number /= factor;
					factors << factor << " x ";
				}
			}
		}
		max_prime_factor = factor;
		std::cout << "factors: " << factors.str() << "\n";
		break;
	}
	}

	std::cout << "Result: " << max_prime_factor << '\n';
}

template <typename T>
int CountOfDigits(T value) {
	if (static_cast<int>(value) == 0) {
		return 1;
	}

	int count = 0;
	while (static_cast<int>(value) != 0) {
		value /= 10;
		++count;
	}
	return count;
}

bool IsPalindrome(int test) {
	const auto str = std::to_string(test);
	auto left = str.size() - 1;
	int64_t right = 0;
	const auto data = str.c_str();
	auto is_palindrome = true;
	while (left > right) {
		if (data[left] != data[right]) {
			is_palindrome = false;
			break;
		}
		--left;
		++right;
	}
	return is_palindrome;
}

void project4(int method) {
	cout <<
		"A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 ? 99\n";
	cout << "Find the largest palindrome made from the product of two 3 - digit numbers.\n";
	int max_palindrome = -1;
	int f1, f2;
	for (int factor1 = 999; factor1 > 99; --factor1) {
		for (int factor2 = 999; factor2 >= factor1; --factor2) {
			const auto value = factor1 * factor2;
			if (IsPalindrome(value) && value > max_palindrome) {
				f1 = factor1;
				f2 = factor2;
				max_palindrome = value;
			}
		}
	}
	//906609 13..15ms
	cout << "Result: " << max_palindrome << '\n';
}

void project5(int method) {
	cout <<
		"2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\n";
	cout << "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20 ? \n";
	bool found;
	int val = 20;
	const int max = INT_MAX;
	do {
		val += 20;
		if (max - val < 20) {
			break;
		}
		found = true;
		for (int factor = 3; factor < 20; ++factor) {
			if (val % factor != 0) {
				found = false;
				break;
			}
		}
	}
	while (!found);
	cout << "Result: " << val << '\n';
}

void project6(int method) {
	cout << "Hence the difference between the sum of the squares of the first ten natural numbers\n";
	cout << "and the square of the sum is 3025 - 385 = 2640.\n";
	cout << "Find the difference between the sum of the squares of the first one hundred natural numbers\n";
	cout << "and the square of the sum.\n";
	enum Method {
		kFirst = 1,
		kSecond
	} const m = static_cast<Method>(method ? method : kFirst);

	int result = 0;

	if (m == kFirst) {
		int sum1 = 0;
		int sum2 = 0;
		for (int i = 1; i <= 100; ++i) {
			sum1 += i * i;
			sum2 += i;
		}
		sum2 *= sum2;
		result = sum2 - sum1;
	}
	else if (m == kSecond) {
		for (int i = 1; i < 100; ++i) {
			for (int j = i + 1; j <= 100; ++j) {
				result += i * j;
			}
		}
		result = result << 1;
	}
	// 25164150 2ms
	cout << "Result: " << result << '\n';
}

void project7(int method) {
	cout << "By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\n";
	cout << "What is the 10 001st prime number ?\n";
	enum Method {
		kFirst = 1,
		kSecond = 2
	} const m = static_cast<Method>(method ? method : kFirst);

	int prime = 0;
	if (m == kFirst) {
		int prime_count = 6;
		int test = 15;
		prime = -1;
		while (prime_count != 10001) {
			if (IsPrime(test)) {
				prime = test;
				++prime_count;
			}
			test += 2;
		}
	}
	else if (m == kSecond) {
		int prime_count = 6;
		//TODO allocate in heap
		int primes[10001] = {2, 3, 5, 7, 11, 13};
		int test = 15;
		while (prime_count != 10001) {
			if (IsPrime(primes, prime_count, test)) {
				prime = test;
				primes[prime_count] = prime;
				++prime_count;
			}
			test += 2;
		}
	}
	//kFirst ~5sec result: 104743
	//kSecond ~23ms result: 104743
	cout << "Result: " << prime << '\n';
}

void project8(int method) {
	cout << "he four adjacent digits in the 1000-digit number that have the greatest product are\n";
	cout << " 9 x 9 x 8 x 9 = 5832.\n";
	cout << "Find the thirteen adjacent digits in the 1000-digit number\n";
	cout << "that have the greatest product. What is the value of this product?\n";

	string text = "73167176531330624919225119674426574742355349194934"
		"96983520312774506326239578318016984801869478851843"
		"85861560789112949495459501737958331952853208805511"
		"12540698747158523863050715693290963295227443043557"
		"66896648950445244523161731856403098711121722383113"
		"62229893423380308135336276614282806444486645238749"
		"30358907296290491560440772390713810515859307960866"
		"70172427121883998797908792274921901699720888093776"
		"65727333001053367881220235421809751254540594752243"
		"52584907711670556013604839586446706324415722155397"
		"3697817977846174064955149290862569321978468622482"
		"83972241375657056057490261407972968652414535100474"
		"82166370484403199890008895243450658541227588666881"
		"16427171479924442928230863465674813919123162824586"
		"17866458359124566529476545682848912883142607690042"
		"24219022671055626321111109370544217506941658960408"
		"07198403850962455444362981230987879927244284909188"
		"84580156166097919133875499200524063689912560717606"
		"05886116467109405077541002256983155200055935729725"
		"71636269561882670428252483600823257530420752963450";
	int64_t result = 0;
	enum Method {
		kFirst,
		kSecond
	} const m = static_cast<Method>(method ? method : kFirst);
	switch (method) {
	case kFirst:
		auto begin = 0;
		auto end = 13;
		const int_fast64_t len = text.length();
		int64_t max_product = 0;
		while (end != len) {
			int64_t product = 1;
			for (auto i = begin; i < end; ++i) {
				product *= std::stol(text.substr(i, 1));
			}
			if (product > max_product) {
				max_product = product;
			}
			++begin;
			++end;
		}
		result = max_product;
		break;
	}
	//kFirst 23514624000, 3-4 ms
	cout << "Result: " << result << '\n';
}

void project9(int method) {
	std::cout << "A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\n" <<
		"a2 + b2 = c2\n" <<
		"For example, 32 + 42 = 9 + 16 = 25 = 52.\n" <<
		"There exists exactly one Pythagorean triplet for which a + b + c = 1000.\n" <<
		"Find the product abc.\n";
	enum Method {
		kFirst,
		kSecond
	} m = static_cast<Method>(method ? method : kFirst);
	if (method == kFirst) {
		int a = 0, b = 0, c = 0;
		int64_t iterations = 0;
		for (c = 2; c < 1000; ++c) {
			for (b = 1; b < c; ++b) {
				for (a = 0; a < b; ++a) {
					++iterations;
					if (a + b + c != 1000) {
						continue;
					}
					const int c2 = c * c;
					const int b2 = b * b;
					const int a2 = a * a;
					if (a2 + b2 == c2) {
						std::cout << "Result: " << a * b * c << " a=" << a << ", b=" << b << ", c=" << c << ", iters="
							<< iterations << '\n';
						return;
					}
				}
			}
		}
		//31875000, 23..31ms (~12M iterations)
	}
	else if (method == kSecond) {
		int64_t iterations = 0;
		for (int b = 0; b < 1000; ++b) {
			for (int a = 0; a < b; ++a) {
				++iterations;
				const int c = 1000 - a - b;
				if (a + b + c != 1000) {
					continue;
				}

				const int c2 = c * c;
				const int b2 = b * b;
				const int a2 = a * a;
				if (a2 + b2 == c2) {
					std::cout << "Result: " << a * b * c << " a=" << a << ", b=" << b << ", c=" << c << ", iters=" <<
						iterations << '\n';
					return;
				}
			}
		}
		//31875000, 3ms (~70K iterations)
	}
}

void project10(int method) {
	std::cout << "The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n" <<
		"Find the sum of all the primes below two million.\n";

	//below 2 million top limit ~ 500 000 primary numbers
	try {
		const auto prime_test_limit = 2000000;
		const int max_prime_numbers = 500000;
		const auto primes = new int[max_prime_numbers];
		primes[0] = 2;
		primes[1] = 3;
		primes[2] = 5;
		primes[3] = 7;
		int64_t sum = 2 + 3 + 5 + 7;
		auto prime_count = 4;
		for (int test = 9; test < prime_test_limit; test += 2) {
			assert(prime_count < max_prime_numbers);
			if (IsPrime(primes, prime_count, test)) {
				primes[prime_count++] = test;
				sum += test;
			}
		}
		std::cout << "Result: " << sum << '\n';
		delete[]primes;
	}
	catch (std::bad_alloc& e) {
		std::cout << e.what() << '\n';
	}
	//142913828922 , 503..520ms
}

int32_t HorRightProd(int32_t mat[][20], std::pair<int, int>&& p) {
	auto& x = p.first;
	auto& y = p.second;

	if (x > 16) {
		return 0;
	}

	return mat[y][x] * mat[y][x + 1] * mat[y][x + 2] * mat[y][x + 3];
}

int32_t HorLeftProd(int32_t mat[][20], std::pair<int, int>&& p) {
	auto& x = p.first;
	auto& y = p.second;

	if (x < 3) {
		return 0;
	}

	return mat[y][x - 3] * mat[y][x - 2] * mat[y][x - 1] * mat[y][x];
}

int32_t VerBottomProd(int32_t mat[][20], std::pair<int, int>&& p) {
	const auto& x = p.first;
	const auto& y = p.second;

	if (y > 16) {
		return 0;
	}

	return mat[y][x] * mat[y + 1][x] * mat[y + 2][x] * mat[y + 3][x];
}

int32_t VerUpProd(int32_t mat[][20], std::pair<int, int>&& p) {
	const auto& x = p.first;
	const auto& y = p.second;

	if (y < 3) {
		return 0;
	}

	return mat[y - 3][x] * mat[y - 2][x] * mat[y - 1][x] * mat[y][x];
}

int32_t DiagBottomRightProd(int32_t mat[][20], std::pair<int, int>&& p) {
	const auto& x = p.first;
	const auto& y = p.second;
	if (x > 16) {
		return 0;
	}
	if (y > 16) {
		return 0;
	}

	return mat[y][x] * mat[y + 1][x + 1] * mat[y + 2][x + 2] * mat[y + 3][x + 3];
}

int32_t DiagUpLeftProd(int32_t mat[][20], std::pair<int, int>&& p) {
	const auto& x = p.first;
	const auto& y = p.second;
	if (x < 3) {
		return 0;
	}
	if (y < 3) {
		return 0;
	}

	return mat[y][x] * mat[y - 1][x - 1] * mat[y - 2][x - 2] * mat[y - 3][x - 3];
}

int32_t DiagBottomLeftProd(int32_t mat[][20], std::pair<int, int>&& p) {
	const auto& x = p.first;
	const auto& y = p.second;
	if (x < 3) {
		return 0;
	}
	if (y > 16) {
		return 0;
	}

	return mat[y][x] * mat[y + 1][x - 1] * mat[y + 2][x - 2] * mat[y + 3][x - 3];
}

int32_t DiagUpRightProd(int32_t mat[][20], std::pair<int, int>&& p) {
	const auto& x = p.first;
	const auto& y = p.second;
	if (x > 16) {
		return 0;
	}
	if (y < 3) {
		return 0;
	}

	return mat[y][x] * mat[y - 1][x + 1] * mat[y - 2][x + 2] * mat[y - 3][x + 3];
}

void project11(int method) {
	std::cout << "In the 20x20 grid below, four numbers along a diagonal line have been marked in red.\n";
	int32_t mat[20][20] =
	{
		{8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8},
		{49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0},
		{81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65},
		{52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91},
		{22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},
		{24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},
		{32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},
		{67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21},
		{24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},
		{21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95},
		{78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92},
		{16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57},
		{86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},
		{19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40},
		{4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},
		{88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},
		{4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36},
		{20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16},
		{20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54},
		{1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48},
	};
	std::cout << "The product of these numbers is 26 x 63 x 78 x 14 = 1788696.\n" <<
		"What is the greatest product of four adjacent numbers in the same direction(up, down, left, right, or diagonally) in the 20x20 grid ?\n";

	enum class Method {
		kFirst = 1
	} const m = static_cast<Method>(method);

	if (m == Method::kFirst) {
		auto max_product = 0;
		using ProdFun = std::function<int32_t(int32_t [][20], std::pair<int, int>)>;
		std::vector<ProdFun> v;
		v.emplace_back(&HorRightProd);
		v.emplace_back(&VerBottomProd);
		v.emplace_back(&DiagBottomRightProd);
		v.emplace_back(&DiagBottomLeftProd);

		std::vector<std::string> names;
		names.emplace_back("HorRightProd");
		names.emplace_back("VerBottomProd");
		names.emplace_back("DiagBottomRightProd");
		names.emplace_back("DiagBottomLeftProd");

		int max_x = 0;
		int max_y = 0;
		std::string max_name;
		for (int y = 0; y < 20; ++y) {
			for (int x = 0; x < 20; ++x) {
				int dir = 0;
				std::for_each(v.begin(), v.end(), [&](auto fn) {
					const auto product = fn(mat, {x, y});
					if (max_product < product) {
						max_product = product;
						max_x = x;
						max_y = y;
						max_name = names[dir];
					}
					++dir;
				});
			}
		}
		//70600674, {x: 6, y: 12}
		std::cout << "Result: " << max_product << " max_x: " << max_x << " max_y: " << max_y << " max_name: " <<
			max_name << '\n';
	}
}

void project12(int method) {
	std::cout << "The sequence of triangle numbers is generated by adding the natural numbers.\n";
	std::cout << "So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\n";
	std::cout << "1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n";
	std::cout << "Let us list the factors of the first seven triangle numbers:\n";
	std::cout << " 1: 1\n";
	std::cout << " 3: 1,3\n";
	std::cout << " 6: 1,2,3,6\n";
	std::cout << " 10: 1,2,5,10\n";
	std::cout << " 15: 1,3,5,15\n";
	std::cout << " 21: 1,3,7,21\n";
	std::cout << " 28: 1,2,4,7,14,28\n";
	std::cout << "We can see that 28 is the first triangle number to have over five divisors.\n";
	std::cout << "What is the value of the first triangle number to have over five hundred divisors?\n";
}

int main(int argc, char** argv) {
	//std::cout << 600851475143 % 22567;
	//exit(0);

	using namespace std::chrono;

	//__debugbreak();
	auto problem = -1;
	auto method = -1;
	if (argc == 1) {
		std::cout << "Using program_euler.exe <problem number> <method number>\n";
		std::cout << "problem number: ";
		std::cin >> problem;
		std::cout << "method: ";
		std::cin >> method;
	}
	else {
		problem = std::stol(argv[1]);
		method = 0;
		if (argc == 3) {
			method = std::stol(argv[2]);
		}
	}

	std::cout << "Selected problem: " << problem << " Selected method: " << method << '\n';

	const auto tp = steady_clock::now();

	std::map<int32_t, std::function<void(int32_t)>> solved_problems;
	solved_problems[1] = &project1;
	solved_problems[2] = &project2;
	solved_problems[3] = &project3;
	solved_problems[4] = &project4;
	solved_problems[5] = &project5;
	solved_problems[6] = &project6;
	solved_problems[7] = &project7;
	solved_problems[8] = &project8;
	solved_problems[9] = &project9;
	solved_problems[10] = &project10;
	solved_problems[11] = &project11;

	if (solved_problems.find(problem) == solved_problems.end()) {
		std::cout << "Problem " << problem << " not solved yet, try later:P\n";
	}
	else {
		solved_problems[problem](method);
	}

	std::cout << "time:" << duration_cast<milliseconds>(steady_clock::now() - tp).count() << " ms";
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
